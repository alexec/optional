// Optional is a tool that generates 'optional' type wrappers around a given type T.
//
// Typically this process would be run using go generate, like this:
//
//	//go:generate optional -type=Foo
//
// running this command
//
//	optional -type=Foo
//
// in the same directory will create the file optional_foo.go
// containing a definition of
//
//	type OptionalFoo struct {
//		...
//	}
//
// The default type is OptionalT or optionalT (depending on if the type is exported)
// and output file is optional_t.go. This can be overridden with the -output flag.
//
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/build"
	"io/ioutil"
	"log"
	"os"
	"strings"
	"text/template"
)

type generator struct {
	packageName string
	outputName  string
	typeName    string
	result      bool // if true, generate a Result<T,E> type, otherwise Optional<T>
}

func (g *generator) generate() ([]byte, error) {

	var (
		t = template.Must(template.New("").Parse(tmpl[g.result]))

		data = struct {
			PackageName        string
			TypeName           string
			ExportedName       string
			OutputName         string
			ExportedOutputName string
			VariableName       string
		}{
			g.packageName,
			g.typeName,
			strings.Title(g.typeName),
			g.outputName,
			strings.Title(g.outputName),
			strings.ToLower(string(g.outputName[0])),
		}

		buf bytes.Buffer
		err = t.Execute(&buf, data)
	)

	if err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("optional: ")

	var (
		typeName   = flag.String("type", "", "type name; must be set")
		outputName = flag.String("output", "", "output type and file name; default [o|O]ptional<type> and srcdir/optional_<type>.go")
		result     = flag.Bool("result", false, "generate a result type")
	)

	flag.Parse()

	if len(*typeName) == 0 {
		flag.Usage()
		os.Exit(2)
	}

	pkg, err := build.Default.ImportDir(".", 0)
	if err != nil {
		log.Fatal(err)
	}

	var (
		filename string
		g        generator
	)

	g.typeName = *typeName
	g.packageName = pkg.Name
	g.result = *result

	if len(*outputName) == 0 {
		// no output specified, use default optional_<type>

		// TODO: may not be the most reliable method
		exported := strings.Title(g.typeName) == g.typeName

		prefix := "Optional"
		if *result {
			prefix = "Result"
		}
		if !exported {
			prefix = strings.ToLower(prefix)
		}
		g.outputName = prefix + strings.Title(g.typeName)
		filename = fmt.Sprintf("%s_%s.go", strings.ToLower(prefix), strings.ToLower(g.typeName))
	} else {
		g.outputName = *outputName
		filename = strings.ToLower(g.outputName + ".go")
	}

	src, err := g.generate()
	if err != nil {
		log.Fatal(err)
	}

	if err = ioutil.WriteFile(filename, src, 0644); err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

var tmpl = map[bool]string{
	false: `// Code generated by optional. DO NOT EDIT.

package {{ .PackageName }}

import (
{{- if and (ne .TypeName "complex64") (ne .TypeName "complex128") }}
	"encoding/json"
{{- end }}
	"errors"
)

// {{ .OutputName }} is an optional {{ .TypeName }}.
type {{ .OutputName }} struct {
	value *{{ .TypeName }}
}

// New{{ .OutputName }} creates an optional.{{ .OutputName }} from a {{ .TypeName }}.
func New{{ .OutputName }}(v {{ .TypeName }}) {{ .OutputName }} {
	return {{ .OutputName }}{&v}
}

// Set sets the {{ .TypeName }} value.
func ({{ .VariableName }} *{{ .OutputName }}) Set(v {{ .TypeName }}) {
	{{ .VariableName }}.value = &v
}

// Get returns the {{ .TypeName }} value or an error if not present.
func ({{ .VariableName }} {{ .OutputName }}) Get() ({{ .TypeName }}, error) {
	if !{{ .VariableName }}.Present() {
		var zero {{ .TypeName }}
		return zero, errors.New("value not present")
	}
	return *{{ .VariableName }}.value, nil
}

// MustGet returns the {{ .TypeName }} value or panics if not present.
func ({{ .VariableName }} {{ .OutputName }}) MustGet() {{ .TypeName }} {
	if !{{ .VariableName }}.Present() {
		panic("value not present")
	}
	return *{{ .VariableName }}.value
}

// Present returns whether or not the value is present.
func ({{ .VariableName }} {{ .OutputName }}) Present() bool {
	return {{ .VariableName }}.value != nil
}

// OrElse returns the {{ .TypeName }} value or a default value if the value is not present.
func ({{ .VariableName }} {{ .OutputName }}) OrElse(v {{ .TypeName }}) {{ .TypeName }} {
	if {{ .VariableName }}.Present() {
		return *{{ .VariableName }}.value
	}
	return v
}

// If calls the function f with the value if the value is present.
func ({{ .VariableName }} {{ .OutputName }}) If(fn func({{ .TypeName }})) {
	if {{ .VariableName }}.Present() {
		fn(*{{ .VariableName }}.value)
	}
}

{{- if and (ne .TypeName "complex64") (ne .TypeName "complex128") }}

func ({{ .VariableName }} {{ .OutputName }}) MarshalJSON() ([]byte, error) {
	if {{ .VariableName }}.Present() {
		return json.Marshal({{ .VariableName }}.value)
	}
	return json.Marshal(nil)
}

func ({{ .VariableName }} *{{ .OutputName }}) UnmarshalJSON(data []byte) error {

	if string(data) == "null" {
		{{ .VariableName }}.value = nil
		return nil
	}

	var value {{ .TypeName }}

	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}

	{{ .VariableName }}.value = &value
	return nil
}
{{- end }}
`,
	true: `// Code generated by optional. DO NOT EDIT.

package {{ .PackageName }}

import (
	"errors"
)

// {{ .OutputName }} is an result {{ .TypeName }}.
type {{ .OutputName }} struct {
	value *{{ .TypeName }}
	err   error
}

func New{{ .ExportedOutputName }}(v {{ .TypeName }}, err error) {{ .OutputName }} {
	if err != nil {
		return Err{{ .ExportedName }}(err)
	} else {
		return Ok{{ .ExportedName }}(v)
	}
}

func New{{ .ExportedOutputName }}Ptr(v *{{ .TypeName }}, err error) {{ .OutputName }} {
	if v == nil && err == nil {
		panic("both value and err are nil")
	}
	if err != nil {
		return Err{{ .ExportedName }}(err)
	} else {
		return Ok{{ .ExportedName }}(*v)
	}
}

func Ok{{ .ExportedName }}(v {{ .TypeName }}) {{ .OutputName }} {
	return {{ .OutputName }}{value: &v}
}

func Err{{ .ExportedName }}(err error) {{ .OutputName }} {
	return {{ .OutputName }}{err: err}
}

func ({{ .VariableName }} {{ .OutputName }}) Value() {{ .TypeName }} {
	if {{ .VariableName }}.value == nil {
		panic("value not present")
	}
	return *{{ .VariableName }}.value
}

func ({{ .VariableName }} {{ .OutputName }}) Err() error {
	if {{ .VariableName }}.err == nil {
		panic("err not present")
	}
	return {{ .VariableName }}.err
}

func ({{ .VariableName }} {{ .OutputName }}) Get() ({{ .TypeName }}, error) {
	if {{ .VariableName }}.value == nil {
		var zero {{ .TypeName }}
		return zero, errors.New("value not present")
	}
	return *{{ .VariableName }}.value, nil
}

func ({{ .VariableName }} {{ .OutputName }}) Present() bool {
	return {{ .VariableName }}.value != nil
}
`,
}
